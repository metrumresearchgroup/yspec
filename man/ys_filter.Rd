% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ys-tidy.R
\name{ys_filter}
\alias{ys_filter}
\title{Subset yspec items using column values}
\usage{
ys_filter(x, expr, .default = NULL, .enclos = parent.frame())
}
\arguments{
\item{x}{A yspec object.}

\item{expr}{An unquoted expression.}

\item{.default}{A named list or environment containing defaults for \code{expr};
consider using \code{\link[=ys_fill_dots]{ys_fill_dots()}} as an alternative to passing \code{.default}.}

\item{.enclos}{An enclosing environment for evaluating \code{expr}.}
}
\value{
A \code{yspec} object
}
\description{
The intended use is to subset based on variables define in the \code{dots} list,
however some internal column data is also available to query.
}
\details{
The following fields always exist in the spec and are available for
querying in the filter expression:
\itemize{
\item \code{col}:  column name \verb{<character>}
\item \code{type}: data type \verb{<character>}; either numeric, character, or integer
\item \code{discrete}: discrete data flag \verb{<logical>}; yspec sets this to \code{TRUE}
when the \code{values} field is populated
\item \code{continuous}: continuous data flag \verb{<logical>}; yspec sets this to \code{TRUE}
when the \code{range} field is populated
\item \code{short}: the short name \verb{<character>}
\item \code{do_lookup}: lookup indicator; yspec sets this to \code{TRUE} when some or all
of the column data is defined by an external lookup file
}

The following fields will be provided defaults when the filter expression
is evaluated:
\itemize{
\item \code{unit}: as specified by the user \verb{<character>}; default value is  ""
\item \code{covariate}: as specified by the user in \code{dots} \verb{<logical>}; default value
is \code{FALSE}
}

In addition to these fields, you can build the filter expression using
items in the \code{dots} field.
}
\section{Evaluation environment}{

In order to determine if any column should get selected, \code{ys_filter()},
builds an environment and evaluates \code{expr} in that environment. Columns are
selected only if \code{expr} evaluates to \code{TRUE} (via \code{\link[=isTRUE]{isTRUE()}}).

The environment is comprised of pre-existing data items in the spec (e.g.
\code{col} or \code{short}; these items are always present), data items in the enclosing
environment (\code{.enclos}; this defaults to \code{parent.frame()}), the \code{.defaults}
list (passed by the user at run time) and the \code{.dots} list associated with
each column.

Users are encouraged to filter based on logical data items in \code{dots} that are
set through the \code{flags} field in \code{SETUP__}. When \code{flags} are set, every
column is given a logical data item that can always be evaluated for every
column. This is the safest and simplest way to go and should be the target
usage. In case more complicated applications are required, users can appeal
to data items in \code{dots} which may or may not be logical. Of course, the user
can enter data into \code{dots} for every column to ensure that data item is
available for evaluating \code{expr} but that might not be very convenient. In
that case, pass a list of \code{.defaults} that will be used when the filter
variable isn't available in \code{dots}. As an alternative to using \code{.defaults},
the user can run the \code{spec} object through \code{ys_dots_fill} which will
fill in dots data items with default values only when they don't exist. This
is probably more convenient, but the user is warned that these data items
in \code{dots} stay with the \code{yspec} object for the life of the object.
}

\examples{
spec <- ys_help$spec()

ys_filter(spec, is.character(decode))

ys_filter(spec, unit == "kg" | type == "character")

ys_filter(spec, covariate)

}
\seealso{
\code{\link[=ys_rename]{ys_rename()}}, \code{\link[=ys_join]{ys_join()}}, \code{\link[=ys_select]{ys_select()}}, \code{\link[=ys_fill_dots]{ys_fill_dots()}}
}
